# 构建工具横向对比

[Comparing the New Generation of Build Tools](https://css-tricks.com/comparing-the-new-generation-of-build-tools/)

[[精读《新一代前端构建工具对比》](https://segmentfault.com/a/1190000040010523)](https://segmentfault.com/a/1190000040010523)

[【第九期】Rollup：下一代ES模块打包工具](https://zhuanlan.zhihu.com/p/75717476)



## 新一代前端构建工具对比

### esbuild

esbuild 使用 go 语言编写，由于相对 node 更为底层，且不提供 AST 操作能力，所以代码执行效率更高，根据其官方 benchmark 介绍提速有 10～100 倍。

esbuild 有两大功能，分别是 bundler 与 minifier，其中 bundler 用于代码编译，类似 babel-loader、ts-loader；minifier 用于代码压缩，类似 terser。

但由于 esbuild 无法操作 AST，所以一些需要操作 AST 的 babel 插件无法与之兼容，导致生产环境很少直接使用 esbuild 的 bundler 模块。

幸运的是 minifier 模块可以直接替换 terser 使用，可以用于生产环境。

esbuild 比较底层，所以可以与后续介绍的上层构建工具结合使用，当然根据工具设计理念，是否内置，内置到什么程度，以及是否允许通过插件替换就是另一回事了。



### snowpack

 [精读 snowpack](https://link.segmentfault.com/?enc=dV1gk%2F0OPaSvdAVH5D3rlA%3D%3D.a4U8VQz8DsxJdsU%2FdSJ4bD1kZjVZGrfwEXV8jJFoUxkuaShkuI%2B9Aq7xtosD6dWOuc1WVRqdhS7mSUbgV47hDlw6OqjuMsPYzxdaxOBvMR7Jij7o60zHn3NK1AeuBwyzG6J%2BUKQ1Uh14zkSY43DJea9IILIbSR4MjVNIndMQGs7eWP9sZAQo3dT1VF8ZjGk6)

snowpack 是一个相对轻量的 bundless 方案，bundless 就是利用浏览器支持的 [ESM import](https://link.segmentfault.com/?enc=N4tV4SfW26fNfvJz6WOcrw%3D%3D.i31uTT%2FEnx8CNKk0i6wjlJWq5yHGZx4R7YCgrkM2uqQ1IR1iVaFZGSSNwvRHKDl2A%2BifmvgmR%2F9LqCBOt1etDu2QateLRMXVMSB2fNthBXy%2FBRVlcEwhW4kSjvLMm363) 特性，利用浏览器进行模块间依赖加载，而不需要在编译时进行。

跳过编译时依赖加载可以省很多事，比如不用考虑 tree shaking 问题，也不用为了最终产物加速而使用缓存，相当于这些工作交给最终执行的浏览器了，而浏览器作为最终运行时容器，比编译时工具更了解应该如何按需加载。

仅从编译时来看，修改单个文件的编译速度与项目整体大小有关，而若不考虑整体项目，仅编译单个文件（最多递归一下有限的依赖模块，解决比如 TS 类型变量判断问题）时间复杂度一定是 O(1) 的。

实际上我们很少单独使用 snowpack，因为其编译使用的 esbuild 还未达到 1.0 稳定版本，在生态兼容与产物稳定性上存在风险，所以编译打包时往往采用 rollup 或 webpack，但这种割裂也导致了开发与生产环境不一致，这往往代表着更大的风险，因此在 vite 框架可以看到这块的取舍。



### vite

可以理解为结合了 snowpack 特色的一站式构建工具，从开发到发布全套流程都帮你搞定。

与 snowpack 不同的是，snowpack 生产打包的产物是独立的文件，而 vite 没有采用 esbuild 而是 rollup 打包，目的是为了打包为一个整体，并规避 esbuild 不稳定的风险。

另外由于 vite 集成化更高，比 snowpack 多了许多功能，比如 css 拆分、多页、使用 esbuild 进行依赖预构建、monorepo 支持、对多框架支持、SSR 等等。

其实革命性突破主要是 bundless，在这基础上发展出一系列便捷的功能，这值得每一个工程化团队学习。其实就算决定再造一个轮子，也是维持 90% 功能不变的基础上，在默认的偏好设置做一些微调，而这些大多可以用 [插件](https://link.segmentfault.com/?enc=ejEZLz4JTSmn5NeUqYnvYw%3D%3D.lU1KXxpLQEWwoB1k1H1bs7TyXhTGJfVrqf18X04ukTOwDXC%2FfJRbFvn1pplNstlB) 解决。

总结下来，Vite 是一个既积极拥抱新特性，又为生产环境考虑的工程化全家桶，相比之下，技术栈过于前沿的工具只能称为玩具，而 Vite 是真的可以用一用的。



### wmr

由 preact 作者开发，可以理解为 preact 版的 vite。所以对于 preact 技术栈的开发者更加友好，集成度更高。

原文提到的另一个特色是，wmr 使用了 [htm](https://link.segmentfault.com/?enc=IgHoa1fNzg313M5Nrgq2vA%3D%3D.%2FqeZtSceS%2Fvp4zfWARo49TZAtCrvSa7YTT2qQ%2Bjw3kQo3t9jIOj9iwLBWPNZXRf%2F) 转换 JSX，使其获得了更加精确的报错体验，即可以精确到源码行的同时指定到具体列。

综合功能和 vite 差不多，单页 + ssr 都支持，如果你平时使用 preact，或者想开发一个体积极小的项目，可以考虑用 wmr 全家桶。

### 小结：

新一代前端构建工具最大特色有两个：更底层的语言编写、bundless，如果用一个词描述就是高性能。积极拥抱浏览器新特性或者知识跨界都可以帮助前端领域取得新的突破。

另外构建工具已经变得越来越集成化，从仅用于编译的 esbuild，到支持开发的 snowpack，再到内置了最佳实践、甚至支持比如 ssr 等后端能力、最后到垂直场景的 [vitePress](https://link.segmentfault.com/?enc=nZYKzBtYJCE30NMrA2%2BxuQ%3D%3D.knRcrm%2FUsCS6mXJoc5rex1M21qlUi2UrZXeZVeVX%2BLp6TtUrn%2BTzh4cYbRJqC3XF)，每抽象一次，都更开箱即用，但带来的灵活性降低也成为各团队自己造轮子的理由，越上层越是有自己造轮子的冲动。

这和可视化领域很像，可视化从最底层的 svg、canvas、webgl 到基于其封装的命令式框架，再到数据驱动开发框架、完全 JSON 配置化的图表库、甚至到零配置，根据数据猜配置的智能化项目，也是配置越来越少，但灵活度越来越低，使用什么层次的完全看项目对细节的要求。



## 传统打包工具对比：



### webpack

Webpack（https://webpack.js.org）是一个打包模块化JavaScript的工具，在Webpack里一切文件皆模块，通过Loader转换文件，通过Plugin注入钩子，最后输出由多个模块组合成的文件。Webpack专注于构建模块化项目。

![image-20211130112920696](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211130112920696.png)

一切文件如JavaScript、CSS、SCSS、图片、模板，对于Webpack来说都是一个个模块，这样的好处是能清晰地描述各个模块之间的依赖关系，以方便Webpack对模块进行组合和打包。经过Webpack的处理，最终会输出浏览器能使用的静态资源。

Webpack具有很大的灵活性，能配置处理文件的方式。

Webpack的优点是：

专注于处理模块化的项目，能做到开箱即用、一步到位；

可通过Plugin扩展，完整好用又不失灵活；

使用场景不局限于Web开发；

社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；

良好的开发体验。

Webpack的缺点是只能用于采用模块化开发的项目。

大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，Webpack可以为这些新项目提供一站式的解决方案；

Webpack有良好的生态链和维护团队，能提供良好的开发体验并保证质量；

Webpack被全世界大量的Web开发者使用和验证，能找到各个层面所需的教程和经验分享。



## rollup

[Rollup](https://rollupjs.org)是一个和Webpack很类似但专注于ES6的模块打包工具。它的亮点在于，能针对ES6源码进行Tree Shaking，以去除那些已被定义但没被使用的代码并进行Scope Hoisting，以减小输出文件的大小和提升运行性能。然而Rollup的这些亮点随后就被Webpack模仿和实现。Rollup的使用方法和Webpack差不多。

- Rollup是在Webpack流行后出现的替代品；

- Rollup生态链还不完善，体验不如Webpack；

- Rollup的功能不如Webpack完善，但其配置和使用更简单；
- 模块过于静态化，HMR很难实现
- 仅面向ES module，无法可靠的处理`commonjs以及umd依赖`
- Rollup不支持Code Spliting，但好处是在打包出来的代码中没有Webpack那段模块的加载、执行和缓存的代码。
- Rollup在用于打包JavaScript库时比Webpack更有优势，因为其打包出来的代码更小、更快，可读性更好。但它的功能不够完善，在很多场景下都找不到现成的解决方案。
- rollup打包后生成的bundle内容十分`干净`，没有什么多余的代码，只是将各个模块按照依赖顺序拼接起来，所有模块构建在一个函数内（Scope Hoisting）, 执行效率更高。相比webpack(webpack打包后会生成__webpack_require__等runtime代码)，rollup拥有无可比拟的性能优势，这是由依赖处理方式决定的，`编译时依赖处理（rollup）自然比运行时依赖处理（webpack）性能更好`
- 支持程序流分析，能更加正确的判断项目本身的代码是否有副作用(配合tree-shaking)
- 支持导出`es`模块文件（webpack不支持导出es模块）

