/**
 *
 * 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。
 * 求按从小到大的顺序的第 n 个丑数。



示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
说明:

1是丑数。
n不超过1690。

 *
 */

/**
 * @description
 * 可以用最小堆+去重来构造一个丑数最小堆，
 * 当堆大小达到n时取出堆顶即可。其时间复杂度为O(n*(logn+log3n))=O(nlogn)和空间复杂度O(n)，
 * 时间和空间复杂度都不太优，因此可以采用动态规划来进行优化：
 * 动态规划。
 * 状态定义：动态规划列表dp,dp[i]表示第i个丑数。
 * 状态转义方程：
 * 使用三个指针p2,p3,p5，初始时指向下标1，
 * 其意义是用指针指向的丑数乘以该指针代表的质因数（分别为2，3，5），
 * dp[i] = {
 *      1                                   i=1
 *      min(dp(p2)*2, dp(p3)*3, dp(p5)*5)   2<=i<=n
 * }
 * 求出dp[i]后，分别于dp(p2)*2、dp(p3)*3、dp(p5)*5比较，如果相等，要将对应的指针+1，
 * 这一步需要全部比较的原因是需要去重，比如当p2=3,p3=2时，3*2和2*3是相等的，
 * 此时无论取p2*2还是p3*3的值(6),如果只移动了其中一个，比如将p2向前移，p2=4,而p3=2
 * 那么下次比较时，p2*2 = 8, p3*3 = 6，假设p5*5比6大，那么又会取到6，此时就重复了。
 * 也就是说虽然每个丑数都有×2、3、5的机会，但如果后面的丑数中先x2、3、5的最小值等于前面这个丑数
 * x2、3、5的某个值，那么前面这个丑数就会丢失通过x2、3、5得到这个值的机会（因为已经存在了），
 * 比如丑数3*2会使丑数2丢失×3的机会，那么x3的机会只能顺延给它的下一个丑数了。
 * @param {number} n
 * @return {number}
 */
function nthUglyNumber(n) {
    if (n < 1) throw new Error('error input < 1');

    const dp = [0, 1];
    let p2 = 1;
    let p3 = 1;
    let p5 = 1;

    for (let i = 2; i <= n; i++) {
        const num2 = dp[p2] * 2;
        const num3 = dp[p3] * 3;
        const num5 = dp[p5] * 5;
        dp[i] = Math.min(num2, num3, num5);
        if (dp[i] === num2) {
            p2++;
        }
        if (dp[i] === num3) {
            p3++;
        }
        if (dp[i] === num5) {
            p5++;
        }
    }

    return dp[n];
}
