# 计算机网络



## 目录

[TOC]

<hr/>



## 好文推荐
- [精读《图解HTTP》 - 白霸天的文章 - 知乎](https://zhuanlan.zhihu.com/p/38548737)
- [超用心的HTTP详解，新手再也不用担心看不懂了 - 慕课网的文章 - 知乎](https://zhuanlan.zhihu.com/p/69768136)
- [精读《趣谈网络协议》](https://github.com/FrankKai/FrankKai.github.io/issues/93)
- [数字签名、数字证书与HTTPS是什么关系？](https://www.zhihu.com/question/52493697)
- [解析HTTPS](https://segmentfault.com/a/1190000012196642)
- [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)



<hr/>

##  1.讲讲http的基本结构？

> 1~7题是根据[写给女朋友的中级前端面试秘籍（含详细答案，15k级别）](https://juejin.cn/post/6844904115428917255#heading-25)中的内容进行补充和附加一些个人总结所得。

- [图解HTTP学习笔记（二）—HTTP协议结构](https://zhuanlan.zhihu.com/p/62304699)

- [扒一扒HTTP的构成 - MrPeak的文章 - 知乎](https://zhuanlan.zhihu.com/p/24314977)

HTTP报文结构：

1. 请求：

   - 请求行	（请求方法、URI、HTTP版本）
   - 首部字段
   - 空行（表示请求体开始）
   - 实体主体（请求体）
   - 空行（表示请求体结束）

2. 响应：

   - 状态行（HTTP版本、状态码、状态原因描述短语）
   - 首部字段
   - 空行（表示响应体开始）
   - 实体主体（响应体）
   - 空行（表示响应体结束）
   

首部字段包括：

- 通用首部字段
- 请求首部字段
- 响应首部字段
- 实体首部字段



____




##  2.说说常用的http状态码？

[HTTP状态码最全汇总 - 向东的文章 - 知乎 ](https://zhuanlan.zhihu.com/p/68184454)



[图片较大，请自行下载](https://gitee.com/ChanningGit/image-hosting/raw/master/images/HTTP状态码.svg)

![HTTP状态码](https://gitee.com/ChanningGit/image-hosting/raw/master/images/HTTP状态码.svg)

![HTTP状态码](/Users/channing/zoom/Study/repo/fikante-interview/packages/02-计算机网络与浏览器/assets/HTTP状态码.svg)



____



## 3.浏览器从输入url到渲染页面，发生了什么？

[细说浏览器输入URL后发生了什么](https://juejin.cn/post/6844904054074654728)

总体分为六步：

1. 合成URL
1. DNS域名解析
2. 建立TCP连接
3. 发起HTTP请求
4. 关闭TCP连接
5. 浏览器渲染

### 合成URL

首先浏览器的UI线程会判断地址栏输入的是搜索内容还是URL，

如果判断其复合URL的规则则会为URL加上协议合成合法的URL。

### DNS域名解析

这一步目的是获取域名对应的IP地址，DNS相当于一个数据库，存储着域名与IP的映射关系。

DNS的域名查找顺序为：浏览器缓存 ➡️本地的host文件➡️本地的DNS解析器缓存➡️本地DNS服务器查找➡️根域名服务器➡️顶级域名服务器➡️权威域名服务器

> 根域名是顶级域名后的. （一般不需要写出来）。最高层次的域名服务器(就好像国家总理一样)，也是最重要的域名服务器。全球有13个根域名服务器名称。
>
> 顶级域名：.com、.edu、.cn等，分为国际和国家两种大类
>
> 权威域名服务器：管理二级及以后的域名的服务器



这里的每一层都可以做缓存。

在查找映射的过程中，也给了应用基于域名做负载均衡的机会，可以说简单的负载均衡，也可以是根据地址和运营商做全局的负载均衡。



### 建立TCP连接

如果是HTTPS，则信息传输都会通过TLS进行加密（HTTPS由HTTP+SSL/TLS两部分组成）。

进行三次握手🤝，建立TCP连接：

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

> 为什么是三次？而不是2、4次？
>
> A：2次太少、4次浪费😓。3次是建立可靠连接的最少次数。

（HTPS）SSL握手过程

1. 第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数
2. 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
3. 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
4. 第四阶段 变更密码构件和结束握手协议

### HTTP请求

服务器收到请求后解析请求头，如果是头部有缓存相关信息如if-match、if-modifyied- since等，服务器验证缓存的有效性，如果有效则返回304，无效则重新返回资源，且状态码为200。

这块的重点是HTTP缓存，可以看后面的面试题。



### 关闭TCP连接

四次挥手：

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
2. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我"同意"你的关闭请求；
3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。



### 浏览器渲染

浏览器渲染的流水线分为：

1. 构建DOM树🌲。渲染进程将HTML内容转换为能够浏览器读懂的DOM树结构。（渲染进程主线程）
2. 样式计算（构建CSSOM树🌲）。渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。（渲染进程主线程）
3. 布局阶段。创建布局树🌲，并计算元素的布局信息。（渲染进程主线程）
4. 分层。对布局树进行分层，并生成分层树🌲。（渲染进程主线程）
5. 栅格化（光栅化）。渲染进程主线程遍历布局树为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转为位图。
6. 显示。合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

![image-20211113172725007](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211113172725007.png)



#### 构建DOM树

浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树,先将HTML的原始字节数据转换为文件指定编码的字符,然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。

具体步骤：

1. 转码（Bytes -> Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串
2. Tokens 化（Characters -> Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则
3. 构建 Nodes（Tokens -> Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）
4. 构建 DOM 树（Nodes -> DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系

#### 样式计算（构建CSSOM树）

渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

CSS 样式来源主要有 3 种，分别是`通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。`其样式计算过程主要为：

1. 属性值标准化。计算一些不容易被渲染引擎理解的属性值，如2em、blue、bold，转成如32px，rgb(0,0,255), 700。
2. 处理样式的继承
3. 处理样式的层叠

#### 页面布局

布局过程，即排除 `script、meta` 等功能化、非视觉节点，排除 `display: none` 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。

其中这个过程需要注意**`回流和重绘`**。具体可见面试题，或者[浏览器相关原理(面试题)详细总结二](https://juejin.cn/post/6844903969693646862#heading-1)。

![image-20211113174208469](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211113174208469.png)

#### 生成分层树

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？详细的可以看另一篇文章[《浏览器相关原理(面试题)详细总结二》](https://juejin.cn/post/6844903969693646862#heading-4)



#### 栅格化

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化（光栅线程）来执行的。所谓栅格化，是指将图块转换为位图。如图：

![image-20211113174747432](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211113174747432.png)



主线程遍历布局树，为每个图层创建绘制顺序列表。

一旦创建了图层树并确定了绘制顺序，主线程就会将该信息提交给合成线程。接着，合成线程分块后再交由光栅线程去光栅化这些图块。一个图层可能会跟整个页面一样大，因此合成线程将它们分块后发送到光栅线程。光栅线程光栅化每个图块后会将它们存储在显存中。

> 合成是一种将页面的各个部分分层，分别光栅化，并在称为合成线程的单独线程中合成为页面的技术。如果发生滚动，由于图层已经光栅化，因此它所要做的只是合成一个新帧。动画也可以以相同的方式（移动图层和合成新帧）实现。

> 合成大量的图层可能会比每帧都光栅化页面的刷新方式更慢。滥用提升合成层的方式来优化可能反而会造成层爆炸的问题。



合成线程会给不同的图块设置优先级，以便视窗（或附近）内的画面可以先被光栅化。图层还具有多个不同分辨率的块，可以处理放大操作等动作。

一旦块被光栅化，合成线程会收集这些块的信息（称为**绘制四边形**）创建**合成帧**。

> 绘制四边形：包含诸如图块在内存中的位置，以及合成时绘制图块在页面中的位置等信息。
>
> 合成帧：一个绘制四边形的集合，代表一个页面的一帧。



#### 显示

最后，合成帧通过 IPC（进程间通讯）提交给浏览器进程。此时，可以从 UI 线程或其他插件的渲染进程添加另一个合成帧。这些合成器帧被发送到 GPU 然后在屏幕上显示，渲染过程完成。

如果接收到滚动事件，合成线程会创建另一个合成帧发送到 GPU。



##### 总结

主线程提交绘制顺序信息给合成线程。

➡️合成线程将图层分块并设置优先级发送到光栅线程。

➡️光栅线程按优先级将图块光栅化为位图并存储在显存中。

➡️合成线程收集光栅化后的图块的信息（绘制四边形），根据视口创建合成帧。

➡️合成线程通过IPC将合成帧提交给浏览器进程，浏览器进程再发送到GPU执行渲染。



> 合成的好处是它可以在不涉及主线程的情况下完成。合成线程不需要等待样式计算或 JavaScript 执行。这就是为什么[仅合成动画](https://link.juejin.cn/?target=https%3A%2F%2Fwww.html5rocks.com%2Fen%2Ftutorials%2Fspeed%2Fhigh-performance-animations%2F)（如transform，opacity等）被认为是流畅性能的最佳选择。如果需要再次计算布局或绘制，则必须涉及主线程。



<hr/>



##  4.讲讲你对cookie的理解？包括SameSite属性。

[预测最近面试会考 Cookie 的 SameSite 属性](https://juejin.cn/post/6844904095711494151)

> 这篇文章可以主要讲chrome80新增的cookie的SameSite属性，另外对于cookie整体也可以复习和回顾一遍，非常棒~



___



##  5. 谈谈https的原理？为什么https能保证安全？

[谈谈 HTTPS](https://juejin.cn/post/6844903504046211079)

[一个故事讲完https](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)

[一文读懂HTTPS以及SSL单向验证和双向验证](https://zhuanlan.zhihu.com/p/143654415)


> https也是一个高频考点，需要过一遍https的加密原理。

https是通过数字证书 + 非对称加密（传输私钥）+对称加密（传输消息）来保证其传输的安全性的。

1. 客户端向服务器发起安全请求
2. 服务器将数字证书发送给客户端
   - 用某种hash算法对服务器信息：公钥、个人信息、使用的hash加密算法方式等其他信息进行加密形成信息摘要
   - 用CA机构的私钥进行对上面的信息摘要加密生成数字签名
   - 服务器信息与数字签名组成数字证书
3. 客户端对数字证书进行验证
   - 客户端用CA机构的公钥对证书的数字签名解密，得到信息摘要
   - 然后客户端用相同的加密算法将服务器信息生成信息摘要
   - 比对两个信息摘要是否相同，若相同则服务器信息未被篡改
   - 客户端验证该服务器信息是否为请求的目标服务器（验证服务器端证书域名和客户端请求域名是否一致，证书是否过期）
4. 客户端验证通过后，生成一个密钥，用服务器发过来的公钥进行加密，发送给服务器。（还有双向验证的方式，客户端也会将自己的证书发送给服务器，这样服务器可以保证只被认证的客户端访问，用于安全性要求高的场景）
5. 服务器用自己的私钥解密获得客户端的私钥
6. 之后就可用对称加密的方式进行加密通信。



**费解问题**🤔

如果第4步里中间人也用服务器的公钥对自己的消息加密再传给服务器，

那么服务器拿到的是中间人的私钥，后续只要中间人用自己的公钥把自己的消息加密发送给服务器，服务器是否就接收到了非客户端的消息？

目前的理解只能是客户端拿到服务器的数字证书并验证通过后就建立起了安全的通信线路，这个阶段中间人就难以介入了。

**自问自答**

通信时使用能够验证用户身份的token即可。由于中间人是无法解密客户端发送的消息的，这样就算把自己的私钥发送给服务器，或者中间人发送自己的消息，只要没有正确的token，服务器就不会对本次请求进行业务处理。

___



## 6.谈谈前端的安全知识？XSS、CSRF，以及如何防范。

[寒冬求职之你必须要懂的Web安全](https://juejin.cn/post/6844903842635579405)



自己之前也整理过一份思维导图，可参考：

[图片太大，请自行下载](https://gitee.com/ChanningGit/image-hosting/raw/master/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8A%A0%E9%95%BF%E7%89%88.png)

![网络安全加长版](https://gitee.com/ChanningGit/image-hosting/raw/master/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8A%A0%E9%95%BF%E7%89%88.png)



![网络安全加长版](/Users/channing/zoom/Study/repo/fikante-interview/packages/02-计算机网络与浏览器/assets/网络安全加长版.png)





> 安全问题也是很多公司必问的，毕竟谁也不希望自己的前端写的网站漏洞百出嘛。









##  7.讲讲http的缓存机制吧，强缓存，协商缓存？

[深入理解浏览器的缓存机制](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F54cc04190252)

> 浏览器缓存基本上是必问的，这篇文章非常值得一看。



缓存位置（按优先级排列）：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache





强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/meG6Vo0Mevgq38cXiaLvaxNIiatrA806UA6eZ3dqoKdgIhPENicUjaXXict6LuQDYsGNHFrddiayooqibHN50ZUCbYog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



___



##  8.http协议发展历史

推荐阅读阮一峰老师的[HTTP协议入门](https://www.ruanyifeng.com/blog/2016/08/http.html)这篇文章，

文章内容通俗易懂，读完后对http协议的一个发展历程有一个清晰的概念，

并且能理解到每个版本更迭背后的原因，解决了哪些痛点以及如何解决，比起死记硬背，充分理解后的记忆才更具系统性（迁移能力，所谓融会贯通）、持续性以及热启动（复习时只需要对相关概念瞄一眼即可轻松回忆起相关知识）。



以下是我根据文章整理的摘要：

### HTTP /0.9

- 只有一个GET请求方法
- 协议规定返回内容只能是HTML格式的字符串（内容格式单一）
- 发起请求即建立TCP连接，发送完毕关闭TCP连接（性能开销大，每次请求都经过TCP连接的建立与关闭）

### HTTP /1.0

- 引入POST、HEAD请求方法（命令）

- 头信息必须是ASCII格式，任何格式的内容都可发送（图像、视频、二进制文件等）（Content-Type）

- 每次通信都需要包含头信息（HTTP header），用于描述元数据

- 新增了状态码、多字符集支持、多部分发送（multipart-type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等

  > **字符集（Charcater Set或Charset）：**是一个系统支持的所有抽象字符的集合，也就是一系列字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。常见的字符集有：ASCII字符集、GB2312字符集(主要用于处理中文汉字)、GBK字符集(主要用于处理中文汉字)、Unicode字符集等。
  >
  > **字符编码（Character Encoding）：**是一套法则，使用该法则能够对自然语言的字符的一个字符集（如字母表或音节表），与计算机能识别的二进制数字进行配对。即它能在符号集合与数字系统之间建立对应关系，是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息，而计算机的信息处理系统则是以二进制的数字来存储和处理信息的。字符编码就是将符号转换为计算机能识别的二进制编码。
  >
  > 一般一个字符集等同于一个编码方式，ANSI体系(ANSI是一种字符代码，为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符)的字符集如ASCII、ISO 8859-1、GB2312、GBK等等都是如此。一般我们说一种编码都是针对某一特定的字符集。 
  > 一个字符集上也可以有多种编码方式，例如UCS字符集(也是Unicode使用的字符集)上有UTF-8、UTF-16、UTF-32等编码方式。
  >
  > 资料来源：https://www.kancloud.cn/digest/visualstudio/110072

- 请求的第一行是请求命令，如GET  / HTTP/1.0

- 回应的格式是头信息 + 一个空行（`\r\n`） + 数据，其中，第一行是"协议版本 + 状态码（status code） + 状态描述"，如HTTP/1.0 200 OK

- Accept声明可接受的数据格式

- Content-Encoding声明数据的压缩方式（gzip、compress、deflate），Accept-Encoding声明接受的压缩方式，如Accept-Encoding: gzip, deflate

缺点：

- 仍然是一个请求一个TCP连接，发送完即关闭，为了解决这个问题部分浏览器在请求时使用了非标准的Connection:keep-alive来要求服务器不要关闭TCP连接。（不能在一个TCP连接中同时发起多个请求）



### HTTP/1.1

97年发布

- 最大变化是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不需要声明connection：keep-alive
  - 客户端可以在发送最后一个请求时附带connection：close明确要求服务器关闭TCP连接
  - 对同一个域名的持久连接有数量限制，视浏览器而不同（大约6个）
- 管道机制，在同一个TCP连接中可以发送多个请求，但服务器依然会按照发送顺序处理请求，因此如果前面的请求处理时间特别久后面的请求就会被阻塞，这就是队头阻塞
- 1.1可以用Content-Length来标记数据块的长度，当为0时说明发送完成，但必须等服务处理完才知道大小。（1.0不需要，因为一个TCP只有一个请求，关闭即完成）
- 为了减缓多个请求的阻塞可以用流模式（stream）或缓存模式（buffer），产生一块数据就发送一块数据，因此1.1可以使用Transfer-Encoding字段表明回应将有数量未定的数据块组成。Transfer-Encoding: chunked。每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。
- 1.1还增加了PUT、PATCH、HEAD、OPTIONS、DELETE方法
- 客户端的请求头增加了Host字段声明来指定服务器的域名。有了Host字段，就可以将请求发送到同一台服务器上的不同网站，为虚拟主机打下基础。

缺点：

- 虽然1.1允许复用TCP连接，但仍然是按次序响应请求的，只有处理完一个回应，才会进行下一个回应，存在队头阻塞问题。
  - 解决方法1：减少请求数（如合并脚本和样式表、图片嵌入CSS代码）
  - 解决方法2：多开持久连接（如域名分片）

### HTTP/2

09年谷歌发布SPDY协议，主要解决1.1的效率问题，验证后作为HTTP2的基础。

- 无子版本、下一个版本将是3

- 彻底的二进制协议，头信息和数据都是二进制，统称为帧（frame），头信息帧和数据帧
  - 二进制协议的好处是可以定义额外的帧，为将来的高级应用打基础。文本的解析比较麻烦，二进制解析方便得多。
  
- 多路复用（多工：双向的、实时的通信），在一个TCP连接中，客户端和浏览器都可以发送多个请求或回应，而不用按照顺序一一对应，避免了队头阻塞

- 数据流
  - 2的数据包不按顺序发送，而是以数据流（每个请求或回应的所有数据包）的方式发送，每个数据流都有一个唯一的ID，且客户端为奇数，服务端为偶数。
  - 数据流发送到一半时，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。（1.1取消请求的唯一方式是关闭TCP连接）
  - 客户端可以指定数据流的优先级，优先级越高服务器越早响应
  
- 头信息压缩
  - HTTP协议是无状态的，每次请求都必须附带所有的信息，因此很多字段是重复的，如Cookie和User Agent的内容是相同的，每次请求都要附带，浪费带宽和速度
  - HTTP/2引入了头信息压缩机制，头信息可以使用gzip或compress压缩后发送，另一方面，客户端和服务器同时维护同一张表，所有字段都会存入这张表，生成一个索引号，以后就不发送同一字段，而是发送索引号即可。
  
- 服务器推送
  - HTTP/2允许服务器未经请求主动向客户端发送资源（server push）
  - 常见的场景如请求一个网页，网页中包含许多静态资源，而正常情况下需要等到解析HTML时再去发起静态资源的请求，而现在服务器可以预判到客户端请求网页后需要哪些静态资源，连同HTML一起发送到客户端。
  
  

___



## 9. 请简述TCP\UDP的区别

TCP和UDP是OSI模型中运输层的协议。TCP提供可靠的通信传输，UDP则常被用于广播和细节控制交给应用的通信传输。

- TCP面向连接，UDP面向非连接（即发送数据前不需要建立连接）
- TCP提供可靠的服务（数据传输），UDP无法保证
- TCP面向字节流，UDP面向报文
- TCP数据传输较慢
- TCP首部开销更大（UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小）
- TCP保证数据顺序，UDP不保证

[TCP和UDP的区别](https://zhuanlan.zhihu.com/p/24860273)



## 10. http请求的方法有哪些?

[HTTP请求方法详解](https://juejin.cn/post/6844903607964270599)

| 方法    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。它期望的应该是而且应该是安全的和幂等的。这里的安全指的是，请求不会影响到资源的状态。 |
| POST    | POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。 |
| PUT     | PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。 |
| DELETE  | DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。 |
| HEAD    | HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。 |
| OPTIONS | OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 |
| CONNECT | CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。 |
| TRACE   | TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。 |
| PATCH   | PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：1.PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。2.当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。 |

> - 幂等：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。
> - GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。
> - 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器在实现时会做一定限制。



## 11. GET和POST有什么区别？

 [GET 和 POST 有什么区别？](https://juejin.cn/post/6844903433212821511)

[W3C](https://www.w3school.com.cn/tags/html_ref_httpmethods.asp)



- 应用场景：GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。
- 是否缓存：因为不同的应用场景，所以浏览器一般会对 Get 请求主动缓存，而 Post 请求缓存不会（除非手动设置）。

- 发送的报文格式：Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。

> 这里其实是错误的说法，GET可以在body中传数据，也可以指定类型，POST也可以在URL中传参

- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

- 安全性：
  - Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，因为请求的 url 会被保留在历史记录中。
  - GET请求在浏览器回退时是无害的，而POST会再次请求

- 请求长度：浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
- 参数类型：GET只允许ASCII字符，而POST 的参数传递支持更多的数据类型。（这里其实也是不准确的）
- GET请求发送一个数据包，POST发送两个
  - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200 OK(返回数据);
    而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 OK(返回数据)。注意，`尽管POST请求会分两次，但body 是紧随在 header 后面发送的，根本不存在『等待服务器响应』一说`。并不是所有浏览器都会在`POST`中发送两次包，`Firefox`就只发送一次

- GET产生的URL地址可以被收藏，而POST不可以。





## 12. POST和PUT的区别？

- PUT请求是向服务器端发送数据的，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时**更新数据**）
- POST请求是向服务器端发送数据的，该请求会改变数据的种类等资源，它可能会创建新的内容。（可以理解为是**创建数据**）

> 在restful中，PUT用于更新数据，POST用于新增数据。
>
> 注意10年推出的PATCH方法，其相当于PUT和POST的合体，当资源已存在则部分更新资源（PUT一般是整体更新资源），若不存在则创建资源，



___





## 13. 现代浏览器内部机制 

[现代浏览器内部机制 Part 1 | 多进程架构](https://cloud.tencent.com/developer/article/1806716)

[现代浏览器内部机制 Part 2 | 导航这件小事](https://cloud.tencent.com/developer/article/1806688)

[现代浏览器内部揭秘（第三部分）渲染进程的内部机制](https://juejin.cn/post/6844903692894732295)

[现代浏览器内部机制（四）： 换个角度看事件](https://cloud.tencent.com/developer/article/1663150?from=article.detail.1806688)



___



## 14.浏览器的渲染原理

[浏览器的渲染原理](https://coolshell.cn/articles/9666.html)

[现代浏览器内部揭秘（第三部分）渲染进程的内部机制](https://juejin.cn/post/6844903692894732295)



___



## 15.OSI七层模型

- 应用层
  - 网络服务与最终用户的一个接口。
  - 协议有：**HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP**
- 表示层
  - 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）
  - 格式有，**JPEG、ASCll、EBCDIC、加密格式等** [2] 
- 会话层
  - 建立、管理、终止会话。（在五层模型里面已经合并到了应用层）
  - **对应主机进程，指本地主机与远程主机正在进行的会话**
- 传输层
  - 定义传输数据的协议端口号，以及流控和差错校验。
  - 协议有：**TCP UDP，数据包一旦离开网卡即进入网络传输层**
- 网络层
  - 进行逻辑地址寻址，实现不同网络之间的路径选择。
  - 协议有：**ICMP IGMP IP（IPV4 IPV6）**
- 数据链路层
  - 建立逻辑连接、进行硬件地址寻址、差错校验 [3] 等功能。（由底层网络定义协议）
  - 将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
- 物理层
  - 建立、维护、断开物理连接。（由底层网络定义协议）



TCP/IP 层级模型结构，[应用层](https://baike.baidu.com/item/应用层)之间的协议通过逐级调用[传输层](https://baike.baidu.com/item/传输层)（Transport layer）、网络层（Network Layer）和物理[数据链路层](https://baike.baidu.com/item/数据链路层)（Physical Data Link）而可以实现应用层的应用程序通信互联。

应用层需要关心应用程序的逻辑细节，而不是数据在网络中的传输活动。应用层其下三层则处理真正的通信细节。在 Internet 整个发展过程中的所有思想和着重点都以一种称为 RFC（Request For Comments）的文档格式存在。针对每一种特定的 TCP/IP 应用，有相应的 RFC [4] 文档。

一些典型的 TCP/IP 应用有 FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD 等。RFC 使一些基本相同的 TCP/IP 应用程序实现了标准化，从而使得不同厂家开发的应用程序可以互相通信。 



___



## 16. WebSocket

[WebSockets-MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API)

[看完让你彻底搞懂Websocket原理](https://juejin.cn/post/6844903606211215373)

[你不知道的 WebSocket](https://juejin.cn/post/6854573221241421838)

[说说对WebSocket的理解？应用场景？](https://vue3js.cn/interview/http/WebSocket.html#%E4%BA%8C%E3%80%81%E7%89%B9%E7%82%B9)





### 原理

WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的。



Websocket 使用 ws 或 wss 的统一资源标志符（URI），其中 wss 表示使用了 TLS 的 Websocket。如：

```js
ws://echo.websocket.org
wss://echo.websocket.org
```



WebSocket 协议使用 80 端口；若运行在 TLS 之上时，默认使用 443 端口。



### 连接过程 —— 握手过程

- 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。
- TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）
  - 客户端发送的请求头中包含：
    - Connection：Upgrade
    - Upgrade：WebSocket
    - Sec-WebSocket-Key：一个Base64 encode的值，浏览器随机生成的字符串，用于验证。
    - Origin：可选字段，类似Referer，表明客户端的来源页面，但只包含协议和主机名。
  - 服务器响应状态码101，将http协议升级到WebSocket协议。
- 服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。
- 当收到了连接成功的消息后，通过TCP通道进行传输通信

![image-20211114235615086](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211114235615086.png)



### WebSocketAPI

WebSocket API 是一个HTML5的 Web API，归属于W3C。

![image-20211114234502340](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211114234502340.png)

![image-20211114234646510](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211114234646510.png)



![image-20211114234707140](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211114234707140.png)



### 示例

```javascript
// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});

```



### 优势

较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。

更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少。

保持连接状态。与 HTTP 不同的是，WebSocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。

更好的二进制支持。WebSocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。

可以支持扩展。WebSocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。



<hr/>

## 17. 说说TCP为什么需要三次握手和四次挥手？

[参考链接](https://vue3js.cn/interview/http/handshakes_waves.html#%E4%B8%80%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)



### 三次握手

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包

主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备

过程如下：

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

上述每一次握手的作用如下：

- 第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常

通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了

#### 为什么不是两次握手?

如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到

并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源 



### 四次挥手

`tcp`终止一个连接，需要经过四次挥手

过程如下：

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态（等待2MSL，以确定服务器收到了，否则服务器会重新发送FIN报文）。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态



#### 四次挥手原因

服务端在收到客户端断开连接`Fin`报文后，并不会立即关闭连接，而是先发送一个`ACK`包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送`FIN`报文断开连接，因此需要四次挥手。



___



## 18. 如何理解CDN？说说实现原理？

https://vue3js.cn/interview/http/CDN.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88



### 一、是什么

CDN (全称 Content Delivery Network)，即内容分发网络

构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。`CDN` 的关键技术主要有内容存储和分发技术

简单来讲，`CDN`就是根据用户位置分配最近的资源

于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**，其实就是缓存了源站内容的代理服务器。如下图：

![img](https://static.vue-js.com/4f0289f0-b86b-11eb-85f6-6fac77c0c9b3.png)

### 二、原理分析

在没有应用`CDN`时，我们使用域名访问某一个站点时的路径为

> 用户提交域名→浏览器对域名进行解释→`DNS` 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复

应用`CDN`后，`DNS` 返回的不再是 `IP` 地址，而是一个`CNAME`(Canonical Name ) 别名记录，指向`CDN`的全局负载均衡

`CNAME`实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是`CDN`实现的关键

#### 负载均衡系统

由于没有返回`IP`地址，于是本地`DNS`会向负载均衡系统再发送请求 ，则进入到`CDN`的全局负载均衡系统进行智能调度：

- 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点
- 看用户所在的运营商网络，找相同网络的边缘节点
- 检查边缘节点的负载情况，找负载较轻的节点
- 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等

结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问`CDN`的缓存代理

整体流程如下图：

![img](https://static.vue-js.com/588d7890-b86b-11eb-85f6-6fac77c0c9b3.png)

#### 缓存代理

缓存系统是 `CDN`的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源

其中有两个衡量`CDN`服务质量的指标：

- 命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比
- 回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比

缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户

回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源

现在的商业 `CDN`命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上

### 三、总结

`CDN` 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度

`CDN` 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速

通过`CDN`的负载均衡系统，智能调度边缘节点提供服务，相当于`CDN`服务的大脑，而缓存系统相当于`CDN`的心脏，缓存命中直接返回给用户，否则回源。



___



## 19. HTTP常见的请求头有哪些？作用？

https://vue3js.cn/interview/http/headers.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88

常见的请求字段如下表所示：

| 字段名            | 说明                                                         | 示例                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept            | 能够接受的回应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Accept-Charset    | 能够接受的字符集                                             | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 能够接受的编码方式列表                                       | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 能够接受的回应内容的自然语言列表                             | Accept-Language: en-US                                       |
| Authorization     | 用于超文本传输协议的认证的认证信息                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 | Cache-Control: no-cache                                      |
| Connection        | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive Connection: Upgrade                   |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie | Cookie: $Version=1; Skin=new;                                |
| Content-Length    | 以 八位字节数组 （8位的字节）表示的请求体的长度              | Content-Length: 348                                          |
| Content-Type      | 请求体的 多媒体类型                                          | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                                       | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| Expect            | 表明客户端要求服务器做出特定的行为                           | Expect: 100-continue                                         |
| Host              | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号 | Host: en.wikipedia.org:80 Host: en.wikipedia.org             |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用是用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                 |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改                | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT             |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回304未修改                | If-None-Match: "737060cd8c284d8af7ad3082f209582d"            |
| If-Range          | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 | If-Range: "737060cd8c284d8af7ad3082f209582d"                 |
| Range             | 仅请求某个实体的一部分                                       | Range: bytes=500-999                                         |
| User-Agent        | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            | 发起一个针对 跨来源资源共享 的请求                           | Origin: http://www.example-social-network.com                |

## 

- 协商缓存是利用的是`【Last-Modified，If-Modified-Since】`和`【ETag、If-None-Match】`这两对请求头响应头来管理的
- 强缓存是利用【Expires，Cache-Control】判断是否命中强缓存的，若命中则不需要发送HTTP请求。
- `Cookie` 主要用于以下三个方面：
  - 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
  - 个性化设置（如用户自定义设置、主题等）
  - 浏览器行为跟踪（如跟踪分析用户行为等）





## 20. 能不能说一说浏览器的本地存储？各自优劣如何？

浏览器的本地存储主要分为`Cookie`、`WebStorage`和`IndexedDB`, 其中`WebStorage`又可以分为`localStorage`和`sessionStorage`。接下来我们就来一一分析这些本地存储方案。

### Cookie

`Cookie` 最开始被设计出来其实并不是来做本地存储的，而是为了弥补`HTTP`在**状态管理上的不足**。

`HTTP` 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？

这种背景下，就产生了 `Cookie`.

Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的`Application`这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。

Cookie 的作用很好理解，就是用来做**状态存储**的，但它也是有诸多致命的缺陷的：

1. 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。

1. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

### localStorage

#### 和Cookie异同

`localStorage`有一点跟`Cookie`一样，就是针对一个域名，即在同一个域名下，会存储相同的一段**localStorage**。

不过它相对`Cookie`还是有相当多的区别的:

1. 容量。localStorage 的容量上限为**5M**，相比于`Cookie`的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。
2. 只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的**性能问题**和**安全问题**。

1. 接口封装。通过`localStorage`暴露在全局，并通过它的 `setItem` 和 `getItem`等方法进行操作，非常方便。

#### 操作方式

接下来我们来具体看看如何来操作`localStorage`。

```plain
let obj = { name: "sanyuan", age: 18 };
localStorage.setItem("name", "sanyuan"); 
localStorage.setItem("info", JSON.stringify(obj));
复制代码
```

接着进入相同的域名时就能拿到相应的值:

```plain
let name = localStorage.getItem("name");
let info = JSON.parse(localStorage.getItem("info"));
复制代码
```

从这里可以看出，`localStorage`其实存储的都是字符串，如果是存储对象需要调用`JSON`的`stringify`方法，并且用`JSON.parse`来解析成对象。

#### 应用场景

利用`localStorage`的较大容量和持久特性，可以利用`localStorage`存储一些内容稳定的资源，比如官网的`logo`，存储`Base64`格式的图片资源，因此利用`localStorage`

### sessionStorage

#### 特点

`sessionStorage`以下方面和`localStorage`一致:

- 容量。容量上限也为 5M。
- 只存在客户端，默认不参与与服务端的通信。

- 接口封装。除了`sessionStorage`名字有所变化，存储方式、操作方式均和`localStorage`一样。

但`sessionStorage`和`localStorage`有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分`sessionStorage`就不复存在了。

#### 应用场景

1. 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
2. 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用`sessionStorage`就再合适不过了。事实上微博就采取了这样的存储方式。

### IndexedDB

`IndexedDB`是运行在浏览器中的`非关系型数据库`, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。

关于它的使用，本文侧重原理，而且 MDN 上的教程文档已经非常详尽，这里就不做赘述了，感兴趣可以看一下[使用文档](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB)。

接着我们来分析一下`IndexedDB`的一些重要特性，除了拥有数据库本身的特性，比如`支持事务`，`存储二进制数据`，还有这样一些特性需要格外注意：

1. 键值对存储。内部采用`对象仓库`存放数据，在这个对象仓库中数据采用**键值对**的方式来存储。
2. 异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。
3. 受同源策略限制，即无法访问跨域的数据库。

### 总结

浏览器中各种本地存储和缓存技术的发展，给前端应用带来了大量的机会，PWA 也正是依托了这些优秀的存储方案才得以发展起来。重新梳理一下这些本地存储方案:

1. `cookie`并不适合存储，而且存在非常多的缺陷。
2. `Web Storage`包括`localStorage`和`sessionStorage`, 默认不会参与和服务器的通信。

1. `IndexedDB`为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。



___



## 21. 什么是跨域？哪些场景会受到限制？为什么会出现跨域问题? 如何解决？



**是什么**：协议（protocol）,主机（host）和端口号（port）有一个不同就是跨域。



**受限制场景：**

- Cookie,LocalStorage无法读取
- DOM和js对象无法读取，主要是iframe（可以说有iframe的对象无法读取）

- Ajax请求不能发送



**为什么：**

浏览器出于安全考虑，一个源的脚本（网页，网站）不能与另一个源的资源进行交互，

所以就引发一个词叫做“同源策略”。

同源策略：同源策略是一种约定，它是浏览器最核心的也最基本的安全功能，如果缺少了同源策略，则

浏览器的正常功能可能会受到影响。

同源：所谓同源（即指在同一个域），就是两个页面具有相同的协议（protocol）,主机（host）和端口号（port）。



**解决方法：**

1. JSONP

- - 利用 <script> 标签没有跨域限制的漏洞，通过 <script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时
  - 只限于 get 请求

- - 基础实现

2. CORS

- - 需要浏览器和后端同时支持
  - 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS

- - 简单请求

- - - 使用 GET、HEAD、POST 方法之一
    - Content-Type

- - - - text/plain
      - multipart/form-data

- - - - application/x-www-form-urlencoded

- - 复杂请求

- - - 预检请求

- - - - 通过该请求来知道服务端是否允许跨域
      - option 方法

3. document.domain

- - 该方式只能用于二级域名相同的情况下，比如a.test.com 和 b.test.com
  - 只需要给页面添加 document.domain = 'test.com'

4. postMessage

- - 通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

5. nginx反向代理

____

