# 计算机网络



## 目录

[TOC]

<hr/>



## 好文推荐
- [精读《图解HTTP》 - 白霸天的文章 - 知乎](https://zhuanlan.zhihu.com/p/38548737)
- [超用心的HTTP详解，新手再也不用担心看不懂了 - 慕课网的文章 - 知乎](https://zhuanlan.zhihu.com/p/69768136)
- [精读《趣谈网络协议》](https://github.com/FrankKai/FrankKai.github.io/issues/93)
- [数字签名、数字证书与HTTPS是什么关系？](https://www.zhihu.com/question/52493697)
- [解析HTTPS](https://segmentfault.com/a/1190000012196642)
- 




<hr/>

##  1.讲讲http的基本结构？

> 1~7题是根据[写给女朋友的中级前端面试秘籍（含详细答案，15k级别）](https://juejin.cn/post/6844904115428917255#heading-25)中的内容进行补充和附加一些个人总结所得。

- [图解HTTP学习笔记（二）—HTTP协议结构](https://zhuanlan.zhihu.com/p/62304699)

- [扒一扒HTTP的构成 - MrPeak的文章 - 知乎](https://zhuanlan.zhihu.com/p/24314977)

HTTP报文结构：

1. 请求：

   - 请求行	（请求方法、URI、HTTP版本）
   - 首部字段
   - 空行（表示请求体开始）
   - 实体主体（请求体）
   - 空行（表示请求体结束）

2. 响应：

   - 状态行（HTTP版本、状态码、状态原因描述短语）
   - 首部字段
   - 空行（表示响应体开始）
   - 实体主体（响应体）
   - 空行（表示响应体结束）
   

首部字段包括：

- 通用首部字段
- 请求首部字段
- 响应首部字段
- 实体首部字段



____




##  2.说说常用的http状态码？

[HTTP状态码最全汇总 - 向东的文章 - 知乎 ](https://zhuanlan.zhihu.com/p/68184454)



[图片较大，请自行下载](https://gitee.com/ChanningGit/image-hosting/raw/master/images/HTTP状态码.svg)

![HTTP状态码](https://gitee.com/ChanningGit/image-hosting/raw/master/images/HTTP状态码.svg)

![HTTP状态码](/Users/channing/zoom/Study/repo/fikante-interview/packages/02-计算机网络/HTTP状态码.svg)



____



## 3.浏览器从输入url到渲染页面，发生了什么？

[细说浏览器输入URL后发生了什么](https://juejin.cn/post/6844904054074654728)

总体分为五步：

1. DNS域名解析
2. 建立TCP连接
3. 发起HTTP请求
4. 关闭TCP连接
5. 浏览器渲染

### DNS域名解析

这一步目的是获取域名对应的IP地址，DNS相当于一个数据库，存储着域名与IP的映射关系。

DNS的域名查找顺序为：浏览器缓存 ➡️本地的host文件➡️本地的DNS解析器缓存➡️本地DNS服务器查找➡️根域名服务器➡️顶级域名服务器➡️权威域名服务器

> 根域名是顶级域名后的. （一般不需要写出来）。最高层次的域名服务器(就好像国家总理一样)，也是最重要的域名服务器。全球有13个根域名服务器名称。
>
> 顶级域名：.com、.edu、.cn等，分为国际和国家两种大类
>
> 权威域名服务器：管理二级及以后的域名的服务器



这里的每一层都可以做缓存。

在查找映射的过程中，也给了应用基于域名做负载均衡的机会，可以说简单的负载均衡，也可以是根据地址和运营商做全局的负载均衡。



### 建立TCP连接

如果是HTTPS，则信息传输都会通过TLS进行加密（HTTPS由HTTP+SSL/TLS两部分组成）。

进行三次握手🤝，建立TCP连接：

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

> 为什么是三次？而不是2、4次？
>
> A：2次太少、4次浪费😓。3次是建立可靠连接的最少次数。

（HTPS）SSL握手过程

1. 第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数
2. 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
3. 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
4. 第四阶段 变更密码构件和结束握手协议

### HTTP请求

服务器收到请求后解析请求头，如果是头部有缓存相关信息如if-match、if-modifyied- since等，服务器验证缓存的有效性，如果有效则返回304，无效则重新返回资源，且状态码为200。

这块的重点是HTTP缓存，可以看后面的面试题。



### 关闭TCP连接

四次挥手：

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
2. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我"同意"你的关闭请求；
3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。



### 浏览器渲染

浏览器渲染的流水线分为：

1. 构建DOM树🌲。渲染进程将HTML内容转换为能够浏览器读懂的DOM树结构
2. 样式计算（构建CSSOM树）。渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
3. 布局阶段。创建布局树，并计算元素的布局信息。
4. 分层。对布局树进行分层，并生成分层树🌲。
5. 栅格化。为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转为位图。
6. 显示。合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

![image-20211113172725007](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211113172725007.png)



#### 构建DOM树

浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树,先将HTML的原始字节数据转换为文件指定编码的字符,然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。

具体步骤：

1. 转码（Bytes -> Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串
2. Tokens 化（Characters -> Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则
3. 构建 Nodes（Tokens -> Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）
4. 构建 DOM 树（Nodes -> DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系

#### 样式计算（构建CSSOM树）

渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

CSS 样式来源主要有 3 种，分别是`通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。`其样式计算过程主要为：

1. 属性值标准化。计算一些不容易被渲染引擎理解的属性值，如2em、blue、bold，转成如32px，rgb(0,0,255), 700。
2. 处理样式的继承
3. 处理样式的层叠

#### 页面布局

布局过程，即排除 `script、meta` 等功能化、非视觉节点，排除 `display: none` 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。

其中这个过程需要注意**`回流和重绘`**。具体可见面试题，或者[浏览器相关原理(面试题)详细总结二](https://juejin.cn/post/6844903969693646862#heading-1)。

![image-20211113174208469](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211113174208469.png)

#### 生成分层树

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？详细的可以看另一篇文章[《浏览器相关原理(面试题)详细总结二》](https://juejin.cn/post/6844903969693646862#heading-4)



#### 栅格化

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图：

![image-20211113174747432](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211113174747432.png)

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。



#### 显示

最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。



<hr/>



##  4.讲讲你对cookie的理解？包括SameSite属性。

[预测最近面试会考 Cookie 的 SameSite 属性](https://juejin.cn/post/6844904095711494151)

> 这篇文章可以主要讲chrome80新增的cookie的SameSite属性，另外对于cookie整体也可以复习和回顾一遍，非常棒~



___



##  5. 谈谈https的原理？为什么https能保证安全？

[谈谈 HTTPS](https://juejin.cn/post/6844903504046211079)

[一个故事讲完https](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)

[一文读懂HTTPS以及SSL单向验证和双向验证](https://zhuanlan.zhihu.com/p/143654415)


> https也是一个高频考点，需要过一遍https的加密原理。



https是通过数字证书 + 非对称加密（传输私钥）+对称加密（传输消息）来保证其传输的安全性的。

1. 客户端向服务器发起安全请求
2. 服务器将数字证书发送给客户端
   - 用某种hash算法对服务器信息：公钥、个人信息、使用的hash加密算法方式等其他信息进行加密形成信息摘要
   - 用CA机构的私钥进行对上面的信息摘要加密生成数字签名
   - 服务器信息与数字签名组成数字证书
3. 客户端对数字证书进行验证
   - 客户端用CA机构的公钥对证书的数字签名解密，得到信息摘要
   - 然后客户端用相同的加密算法将服务器信息生成信息摘要
   - 比对两个信息摘要是否相同，若相同则服务器信息未被篡改
   - 客户端验证该服务器信息是否为请求的目标服务器（验证服务器端证书域名和客户端请求域名是否一致，证书是否过期）
4. 客户端验证通过后，生成一个密钥，用服务器发过来的公钥进行加密，发送给服务器。客户端也会将自己的证书发送给服务器（还有双向验证的方式，这样服务器可以保证只被认证的客户端访问，用于安全性要求高的场景）
5. 服务器用自己的私钥解密获得客户端的私钥
6. 之后就可用对称加密的方式进行加密通信。



**费解问题**🤔

如果第4步里中间人也用服务器的公钥对自己的消息加密再传给服务器，

那么服务器拿到的是中间人的私钥，后续只要中间人用自己的公钥把自己的消息加密发送给服务器，服务器是否就接收到了非客户端的消息？

目前的理解只能是客户端拿到服务器的数字证书并验证通过后就建立起了安全的通信线路，这个阶段中间人就难以介入了。

**自问自答**

通信时使用能够验证用户身份的token即可。由于中间人把自己的私钥发送给服务器是无法解密客户端发送的消息的，这样就算中间人发送自己的消息，只要没有正确的token，服务器就不会对本次请求进行业务处理。

___



## 6.谈谈前端的安全知识？XSS、CSRF，以及如何防范。

[寒冬求职之你必须要懂的Web安全](https://juejin.cn/post/6844903842635579405)



自己之前也整理过一份思维导图，可参考：

[图片太大，请自行下载](https://gitee.com/ChanningGit/image-hosting/raw/master/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8A%A0%E9%95%BF%E7%89%88.png)

![网络安全加长版](https://gitee.com/ChanningGit/image-hosting/raw/master/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8A%A0%E9%95%BF%E7%89%88.png)



![网络安全加长版](/Users/channing/zoom/Study/repo/fikante-interview/packages/02-计算机网络/网络安全加长版.png)





> 安全问题也是很多公司必问的，毕竟谁也不希望自己的前端写的网站漏洞百出嘛。









##  7.讲讲http的缓存机制吧，强缓存，协商缓存？

[深入理解浏览器的缓存机制](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F54cc04190252)

> 浏览器缓存基本上是必问的，这篇文章非常值得一看。



强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/meG6Vo0Mevgq38cXiaLvaxNIiatrA806UA6eZ3dqoKdgIhPENicUjaXXict6LuQDYsGNHFrddiayooqibHN50ZUCbYog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



___



##  8.http协议发展历史

推荐阅读阮一峰老师的[HTTP协议入门](https://www.ruanyifeng.com/blog/2016/08/http.html)这篇文章，

文章内容通俗易懂，读完后对http协议的一个发展历程有一个清晰的概念，

并且能理解到每个版本更迭背后的原因，解决了哪些痛点以及如何解决，比起死记硬背，充分理解后的记忆才更具系统性（迁移能力，所谓融会贯通）、持续性以及热启动（复习时只需要对相关概念瞄一眼即可轻松回忆起相关知识）。



以下是我根据文章整理的摘要：

### HTTP /0.9

- 只有一个GET请求方法
- 协议规定返回内容只能是HTML格式的字符串（内容格式单一）
- 发起请求即建立TCP连接，发送完毕关闭TCP连接（性能开销大，每次请求都经过TCP连接的建立与关闭）

### HTTP /1.0

- 引入POST、HEAD请求方法（命令）

- 头信息必须是ASCII格式，任何格式的内容都可发送（图像、视频、二进制文件等）（Content-Type）

- 每次通信都需要包含头信息（HTTP header），用于描述元数据

- 新增了状态码、多字符集支持、多部分发送（multipart-type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等

  > **字符集（Charcater Set或Charset）：**是一个系统支持的所有抽象字符的集合，也就是一系列字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。常见的字符集有：ASCII字符集、GB2312字符集(主要用于处理中文汉字)、GBK字符集(主要用于处理中文汉字)、Unicode字符集等。
  >
  > **字符编码（Character Encoding）：**是一套法则，使用该法则能够对自然语言的字符的一个字符集（如字母表或音节表），与计算机能识别的二进制数字进行配对。即它能在符号集合与数字系统之间建立对应关系，是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息，而计算机的信息处理系统则是以二进制的数字来存储和处理信息的。字符编码就是将符号转换为计算机能识别的二进制编码。
  >
  > 一般一个字符集等同于一个编码方式，ANSI体系(ANSI是一种字符代码，为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符)的字符集如ASCII、ISO 8859-1、GB2312、GBK等等都是如此。一般我们说一种编码都是针对某一特定的字符集。 
  > 一个字符集上也可以有多种编码方式，例如UCS字符集(也是Unicode使用的字符集)上有UTF-8、UTF-16、UTF-32等编码方式。
  >
  > 资料来源：https://www.kancloud.cn/digest/visualstudio/110072

- 请求的第一行是请求命令，如GET  / HTTP/1.0

- 回应的格式是头信息 + 一个空行（`\r\n`） + 数据，其中，第一行是"协议版本 + 状态码（status code） + 状态描述"，如HTTP/1.0 200 OK

- Accept声明可接受的数据格式

- Content-Encoding声明数据的压缩方式（gzip、compress、deflate），Accept-Encoding声明接受的压缩方式，如Accept-Encoding: gzip, deflate

缺点：

- 仍然是一个请求一个TCP连接，发送完即关闭，为了解决这个问题部分浏览器在请求时使用了非标准的Connection:keep-alive来要求服务器不要关闭TCP连接。（不能在一个TCP连接中同时发起多个请求）



### HTTP/1.1

97年发布

- 最大变化是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不需要声明connection：keep-alive
  - 客户端可以在发送最后一个请求时附带connection：close明确要求服务器关闭TCP连接
  - 对同一个域名的持久连接有数量限制，视浏览器而不同（大约6个）
- 管道机制，在同一个TCP连接中可以发送多个请求，但服务器依然会按照发送顺序处理请求，因此如果前面的请求处理时间特别久后面的请求就会被阻塞，这就是队头阻塞
- 1.1可以用Content-Length来标记数据块的长度，当为0时说明发送完成，但必须等服务处理完才知道大小。（1.0不需要，因为一个TCP只有一个请求，关闭即完成）
- 为了减缓多个请求的阻塞可以用流模式（stream）或缓存模式（buffer），产生一块数据就发送一块数据，因此1.1可以使用Transfer-Encoding字段表明回应将有数量未定的数据块组成。Transfer-Encoding: chunked。每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。
- 1.1还增加了PUT、PATCH、HEAD、OPTIONS、DELETE方法
- 客户端的请求头增加了Host字段声明来指定服务器的域名。有了Host字段，就可以将请求发送到同一台服务器上的不同网站，为虚拟主机打下基础。

缺点：

- 虽然1.1允许复用TCP连接，但仍然是按次序响应请求的，只有处理完一个回应，才会进行下一个回应，存在队头阻塞问题。
  - 解决方法1：减少请求数（如合并脚本和样式表、图片嵌入CSS代码）
  - 解决方法2：多开持久连接（如域名分片）

### HTTP/2

09年谷歌发布SPDY协议，主要解决1.1的效率问题，验证后作为HTTP2的基础。

- 无子版本、下一个版本将是3

- 彻底的二进制协议，头信息和数据都是二进制，统称为帧（frame），头信息帧和数据帧
  - 二进制协议的好处是可以定义额外的帧，为将来的高级应用打基础。文本的解析比较麻烦，二进制解析方便得多。
  
- 多路复用（多工：双向的、实时的通信），在一个TCP连接中，客户端和浏览器都可以发送多个请求或回应，而不用按照顺序一一对应，避免了队头阻塞

- 数据流
  - 2的数据包不按顺序发送，而是以数据流（每个请求或回应的所有数据包）的方式发送，每个数据流都有一个唯一的ID，且客户端为奇数，服务端为偶数。
  - 数据流发送到一半时，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。（1.1取消请求的唯一方式是关闭TCP连接）
  - 客户端可以指定数据流的优先级，优先级越高服务器越早响应
  
- 头信息压缩
  - HTTP协议是无状态的，每次请求都必须附带所有的信息，因此很多字段是重复的，如Cookie和User Agent的内容是相同的，每次请求都要附带，浪费带宽和速度
  - HTTP/2引入了头信息压缩机制，头信息可以使用gzip或compress压缩后发送，另一方面，客户端和服务器同时维护同一张表，所有字段都会存入这张表，生成一个索引号，以后就不发送同一字段，而是发送索引号即可。
  
- 服务器推送
  - HTTP/2允许服务器未经请求主动向客户端发送资源（server push）
  - 常见的场景如请求一个网页，网页中包含许多静态资源，而正常情况下需要等到解析HTML时再去发起静态资源的请求，而现在服务器可以预判到客户端请求网页后需要哪些静态资源，连同HTML一起发送到客户端。
  
  

___



## 9. 请简述TCP\UDP的区别

TCP和UDP是OSI模型中运输层的协议。TCP提供可靠的通信传输，UDP则常被用于广播和细节控制交给应用的通信传输。

- TCP面向连接，UDP面向非连接（即发送数据前不需要建立连接）
- TCP提供可靠的服务（数据传输），UDP无法保证
- TCP面向字节流，UDP面向报文
- TCP数据传输慢
- TCP首部开销更大（UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小）
- TCP保证数据顺序，UDP不保证

[TCP和UDP的区别](https://zhuanlan.zhihu.com/p/24860273)



## 10. http请求的方法有哪些?

[HTTP请求方法详解](https://juejin.cn/post/6844903607964270599)

| 方法    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。它期望的应该是而且应该是安全的和幂等的。这里的安全指的是，请求不会影响到资源的状态。 |
| POST    | POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。 |
| PUT     | PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。 |
| DELETE  | DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。 |
| HEAD    | HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。 |
| OPTIONS | OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 |
| CONNECT | CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。 |
| TRACE   | TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。 |
| PATCH   | PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：1.PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。2.当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。 |

> - 幂等：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。
> - GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。
> - 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器在实现时会做一定限制。



## 11. GET和POST有什么区别？

 [GET 和 POST 有什么区别？](https://juejin.cn/post/6844903433212821511)

Post 和 Get 是 HTTP 请求的两种方法。

- 应用场景：GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。
- 是否缓存：因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。

- 发送的报文格式：Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。

> 这里其实是错误的说法，GET可以在body中传数据，也可以指定类型，POST也可以在URL中传参。

- 安全性：Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，因为请求的 url 会被保留在历史记录中。

- 请求长度：浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
- 参数类型：post 的参数传递支持更多的数据类型。

> 事实上，这两种方法并没有太大的差别，只是通过RFC定义了它们的场景和作用，赋予了一定的语义化，并在业界中约定俗称地在合适的场景使用合适的请求方法。

## 12. POST和PUT的区别？

- PUT请求是向服务器端发送数据的，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时**更新数据**）
- POST请求是向服务器端发送数据的，该请求会改变数据的种类等资源，它可能会创建新的内容。（可以理解为是**创建数据**）

> 在restful中，PUT用于更新数据，POST用于新增数据。
>
> 注意10年推出的PATCH方法，其相当于PUT和POST的合体，当资源已存在则部分更新资源（PUT一般是整体更新资源），若不存在则创建资源，



___





## 13. 现代浏览器内部机制 

[现代浏览器内部机制 Part 1 | 多进程架构](https://cloud.tencent.com/developer/article/1806716)

[现代浏览器内部机制 Part 2 | 导航这件小事](https://cloud.tencent.com/developer/article/1806688)

[现代浏览器内部揭秘（第三部分）渲染进程的内部机制](https://juejin.cn/post/6844903692894732295)

[现代浏览器内部机制（四）： 换个角度看事件](https://cloud.tencent.com/developer/article/1663150?from=article.detail.1806688)



___



## 14.浏览器的渲染原理

[浏览器的渲染原理](https://coolshell.cn/articles/9666.html)

[现代浏览器内部揭秘（第三部分）渲染进程的内部机制](https://juejin.cn/post/6844903692894732295)



___



## 15.OSI七层模型

- 应用层
  - 网络服务与最终用户的一个接口。
  - 协议有：**HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP**
- 表示层
  - 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）
  - 格式有，**JPEG、ASCll、EBCDIC、加密格式等** [2] 
- 会话层
  - 建立、管理、终止会话。（在五层模型里面已经合并到了应用层）
  - **对应主机进程，指本地主机与远程主机正在进行的会话**
- 传输层
  - 定义传输数据的协议端口号，以及流控和差错校验。
  - 协议有：**TCP UDP，数据包一旦离开网卡即进入网络传输层**
- 网络层
  - 进行逻辑地址寻址，实现不同网络之间的路径选择。
  - 协议有：**ICMP IGMP IP（IPV4 IPV6）**
- 数据链路层
  - 建立逻辑连接、进行硬件地址寻址、差错校验 [3] 等功能。（由底层网络定义协议）
  - 将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
- 物理层
  - 建立、维护、断开物理连接。（由底层网络定义协议）



TCP/IP 层级模型结构，[应用层](https://baike.baidu.com/item/应用层)之间的协议通过逐级调用[传输层](https://baike.baidu.com/item/传输层)（Transport layer）、网络层（Network Layer）和物理[数据链路层](https://baike.baidu.com/item/数据链路层)（Physical Data Link）而可以实现应用层的应用程序通信互联。

应用层需要关心应用程序的逻辑细节，而不是数据在网络中的传输活动。应用层其下三层则处理真正的通信细节。在 Internet 整个发展过程中的所有思想和着重点都以一种称为 RFC（Request For Comments）的文档格式存在。针对每一种特定的 TCP/IP 应用，有相应的 RFC [4] 文档。

一些典型的 TCP/IP 应用有 FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD 等。RFC 使一些基本相同的 TCP/IP 应用程序实现了标准化，从而使得不同厂家开发的应用程序可以互相通信。 



___



## 16. WebSocket

[WebSockets-MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API)

[看完让你彻底搞懂Websocket原理](https://juejin.cn/post/6844903606211215373)

[你不知道的 WebSocket](https://juejin.cn/post/6854573221241421838)

### 原理

WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的。



Websocket 使用 ws 或 wss 的统一资源标志符（URI），其中 wss 表示使用了 TLS 的 Websocket。如：

```js
ws://echo.websocket.org
wss://echo.websocket.org
```



WebSocket 协议使用 80 端口；若运行在 TLS 之上时，默认使用 443 端口。



### 连接过程 —— 握手过程

- 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。
- TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）
  - 客户端发送的请求头中包含：
    - Connection：Upgrade
    - Upgrade：WebSocket
    - Sec-WebSocket-Key：一个Base64 encode的值，浏览器随机生成的字符串，用于验证。
    - Origin：可选字段，类似Referer，表明客户端的来源页面，但只包含协议和主机名。
  - 服务器响应状态码101，将http协议升级到WebSocket协议。
- 服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。
- 当收到了连接成功的消息后，通过TCP通道进行传输通信

![image-20211114235615086](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211114235615086.png)



### WebSocketAPI

WebSocket API 是一个HTML5的 Web API，归属于W3C。

![image-20211114234502340](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211114234502340.png)

![image-20211114234646510](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211114234646510.png)



![image-20211114234707140](https://gitee.com/ChanningGit/image-hosting/raw/master/images/image-20211114234707140.png)



### 示例

```javascript
// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});

```



### 优势

较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。

更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少。

保持连接状态。与 HTTP 不同的是，WebSocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。

更好的二进制支持。WebSocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。

可以支持扩展。WebSocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。



<hr/>



