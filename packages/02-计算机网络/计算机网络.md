# 计算机网络



## 目录

[TOC]

<hr/>



## 好文推荐
- [精读《图解HTTP》 - 白霸天的文章 - 知乎](https://zhuanlan.zhihu.com/p/38548737)
- [超用心的HTTP详解，新手再也不用担心看不懂了 - 慕课网的文章 - 知乎](https://zhuanlan.zhihu.com/p/69768136)
- [精读《趣谈网络协议》](https://github.com/FrankKai/FrankKai.github.io/issues/93)
- [数字签名、数字证书与HTTPS是什么关系？](https://www.zhihu.com/question/52493697)
- [解析HTTPS](https://segmentfault.com/a/1190000012196642)
- 




<hr/>

##  1.讲讲http的基本结构？

- [图解HTTP学习笔记（二）—HTTP协议结构](https://zhuanlan.zhihu.com/p/62304699)

- [扒一扒HTTP的构成 - MrPeak的文章 - 知乎](https://zhuanlan.zhihu.com/p/24314977)

HTTP报文结构：

1. 请求：

   - 请求行	（请求方法、URI、HTTP版本）
   - 首部字段
   - 空行（表示请求体开始）
   - 实体主体（请求体）
   - 空行（表示请求体结束）

   ![image-20211112182630279](https://raw.githubusercontent.com/ChanningHan/images/main/img/image-20211112182630279.png)

2. 响应：

   - 状态行（HTTP版本、状态码、状态原因描述短语）
   - 首部字段
   - 空行（表示响应体开始）
   - 实体主体（响应体）
   - 空行（表示响应体结束）
   
   ![image-20211112182759341](https://raw.githubusercontent.com/ChanningHan/images/main/img/image-20211112182759341.png)

首部字段包括：

- 通用首部字段
- 请求首部字段
- 响应首部字段
- 实体首部字段



____




##  2.说说常用的http状态码？

[HTTP状态码最全汇总 - 向东的文章 - 知乎 ](https://zhuanlan.zhihu.com/p/68184454)

![HTTP状态码](https://raw.githubusercontent.com/ChanningHan/image-hosting/main/images/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.svg)

![HTTP状态码](/Users/channing/zoom/Study/repo/fikante-interview/packages/02-计算机网络/HTTP状态码.svg)

![image-20211113120459522.png](https://i.loli.net/2021/11/13/rgWl8f3LDSunZQU.png)

____



## 3.浏览器从输入url到渲染页面，发生了什么？

[细说浏览器输入URL后发生了什么](https://juejin.cn/post/6844904054074654728)

总体分为五步：

1. DNS域名解析
2. 建立TCP连接
3. 发起HTTP请求
4. 关闭TCP连接
5. 浏览器渲染

### DNS域名解析

这一步目的是获取域名对应的IP地址，DNS相当于一个数据库，存储着域名与IP的映射关系。

DNS的域名查找顺序为：浏览器缓存 ➡️本地的host文件➡️本地的DNS解析器缓存➡️本地DNS服务器查找➡️根域名服务器➡️顶级域名服务器➡️权威域名服务器

> 根域名是顶级域名后的. （一般不需要写出来）。最高层次的域名服务器(就好像国家总理一样)，也是最重要的域名服务器。全球有13个根域名服务器名称。
>
> 顶级域名：.com、.edu、.cn等，分为国际和国家两种大类
>
> 权威域名服务器：管理二级及以后的域名的服务器



这里的每一层都可以做缓存。

在查找映射的过程中，也给了应用基于域名做负载均衡的机会，可以说简单的负载均衡，也可以是根据地址和运营商做全局的负载均衡。



### 建立TCP连接

如果是HTTPS，则信息传输都会通过TLS进行加密（HTTPS由HTTP+SSL/TLS两部分组成）。

进行三次握手🤝，建立TCP连接：

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

> 为什么是三次？而不是2、4次？
>
> A：2次太少、4次浪费😓。3次是建立可靠连接的最少次数。

（HTPS）SSL握手过程

1. 第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数
2. 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
3. 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
4. 第四阶段 变更密码构件和结束握手协议

### HTTP请求

服务器收到请求后解析请求头，如果是头部有缓存相关信息如if-match、if-modifyied- since等，服务器验证缓存的有效性，如果有效则返回304，无效则重新返回资源，且状态码为200。

这块的重点是HTTP缓存，可以看后面的面试题。



### 关闭TCP连接

四次挥手：

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
2. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我"同意"你的关闭请求；
3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。



### 浏览器渲染

浏览器渲染的流水线分为：

1. 构建DOM树🌲。渲染进程将HTML内容转换为能够浏览器读懂的DOM树结构
2. 样式计算（构建CSSOM树）。渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
3. 布局阶段。创建布局树，并计算元素的布局信息。
4. 分层。对布局树进行分层，并生成分层树🌲。
5. 栅格化。为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转为位图。
6. 显示。合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

![image-20211113172725007](https://raw.githubusercontent.com/ChanningHan/image-hosting/main/images/image-20211113172725007.png)



#### 构建DOM树

浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树,先将HTML的原始字节数据转换为文件指定编码的字符,然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。

具体步骤：

1. 转码（Bytes -> Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串
2. Tokens 化（Characters -> Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则
3. 构建 Nodes（Tokens -> Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）
4. 构建 DOM 树（Nodes -> DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系

#### 样式计算（构建CSSOM树）

渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

CSS 样式来源主要有 3 种，分别是`通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。`其样式计算过程主要为：

1. 属性值标准化。计算一些不容易被渲染引擎理解的属性值，如2em、blue、bold，转成如32px，rgb(0,0,255), 700。
2. 处理样式的继承
3. 处理样式的层叠

#### 页面布局

布局过程，即排除 `script、meta` 等功能化、非视觉节点，排除 `display: none` 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。

其中这个过程需要注意**`回流和重绘`**。具体可见面试题，或者[浏览器相关原理(面试题)详细总结二](https://juejin.cn/post/6844903969693646862#heading-1)。

![image-20211113174208469](https://raw.githubusercontent.com/ChanningHan/image-hosting/main/images/image-20211113174208469.png)

#### 生成分层树

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？详细的可以看另一篇文章[《浏览器相关原理(面试题)详细总结二》](https://juejin.cn/post/6844903969693646862#heading-4)



#### 栅格化

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图：

![image-20211113174747432](https://raw.githubusercontent.com/ChanningHan/image-hosting/main/images/image-20211113174747432.png)

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。



#### 显示

最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。



<hr/>



##  4.讲讲你对cookie的理解？包括SameSite属性。

[预测最近面试会考 Cookie 的 SameSite 属性](https://juejin.cn/post/6844904095711494151)

> 这篇文章可以主要讲chrome80新增的cookie的SameSite属性，另外对于cookie整体也可以复习和回顾一遍，非常棒~



___



##  5. 谈谈https的原理？为什么https能保证安全？

[谈谈 HTTPS](https://juejin.cn/post/6844903504046211079)

> https也是一个高频考点，需要过一遍https的加密原理。
>



    scratchGui: GuiReducer,



___



## 6.谈谈前端的安全知识？XSS、CSRF，以及如何防范。

[寒冬求职之你必须要懂的Web安全](https://juejin.cn/post/6844903842635579405)

> 安全问题也是很多公司必问的，毕竟谁也不希望自己的前端写的网站漏洞百出嘛。







##  7.讲讲http的缓存机制吧，强缓存，协商缓存？

[深入理解浏览器的缓存机制](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F54cc04190252)

> 浏览器缓存基本上是必问的，这篇文章非常值得一看。







##  8.http协议发展历史

推荐阅读阮一峰老师的[HTTP协议入门](https://www.ruanyifeng.com/blog/2016/08/http.html)这篇文章，

文章内容通俗易懂，读完后对http协议的一个发展历程有一个清晰的概念，

并且能理解到每个版本更迭背后的原因，解决了哪些痛点以及如何解决，比起死记硬背，充分理解后的记忆才更具系统性（迁移能力，所谓融会贯通）、持续性以及热启动（复习时只需要对相关概念瞄一眼即可轻松回忆起相关知识）。



以下是我根据文章整理的摘要：

### HTTP /0.9

- 只有一个GET请求方法
- 协议规定返回内容只能是HTML格式的字符串（内容格式单一）
- 发起请求即建立TCP连接，发送完毕关闭TCP连接（性能开销大，每次请求都经过TCP连接的建立与关闭）

### HTTP /1.0

- 引入POST、HEAD请求方法（命令）

- 头信息必须是ASCII格式，任何格式的内容都可发送（图像、视频、二进制文件等）（Content-Type）

- 每次通信都需要包含头信息（HTTP header），用于描述元数据

- 新增了状态码、多字符集支持、多部分发送（multipart-type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等

  > **字符集（Charcater Set或Charset）：**是一个系统支持的所有抽象字符的集合，也就是一系列字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。常见的字符集有：ASCII字符集、GB2312字符集(主要用于处理中文汉字)、GBK字符集(主要用于处理中文汉字)、Unicode字符集等。
  >
  > **字符编码（Character Encoding）：**是一套法则，使用该法则能够对自然语言的字符的一个字符集（如字母表或音节表），与计算机能识别的二进制数字进行配对。即它能在符号集合与数字系统之间建立对应关系，是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息，而计算机的信息处理系统则是以二进制的数字来存储和处理信息的。字符编码就是将符号转换为计算机能识别的二进制编码。
  >
  > 一般一个字符集等同于一个编码方式，ANSI体系(ANSI是一种字符代码，为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符)的字符集如ASCII、ISO 8859-1、GB2312、GBK等等都是如此。一般我们说一种编码都是针对某一特定的字符集。 
  > 一个字符集上也可以有多种编码方式，例如UCS字符集(也是Unicode使用的字符集)上有UTF-8、UTF-16、UTF-32等编码方式。
  >
  > 资料来源：https://www.kancloud.cn/digest/visualstudio/110072

- 请求的第一行是请求命令，如GET  / HTTP/1.0

- 回应的格式是头信息 + 一个空行（`\r\n`） + 数据，其中，第一行是"协议版本 + 状态码（status code） + 状态描述"，如HTTP/1.0 200 OK

- Accept声明可接受的数据格式

- Content-Encoding声明数据的压缩方式（gzip、compress、deflate），Accept-Encoding声明接受的压缩方式，如Accept-Encoding: gzip, deflate

缺点：

- 仍然是一个请求一个TCP连接，发送完即关闭，为了解决这个问题部分浏览器在请求时使用了非标准的Connection:keep-alive来要求服务器不要关闭TCP连接。（不能在一个TCP连接中同时发起多个请求）



### HTTP/1.1

97年发布

- 最大变化是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不需要声明connection：keep-alive
  - 客户端可以在发送最后一个请求时附带connection：close明确要求服务器关闭TCP连接
  - 对同一个域名的持久连接有数量限制，视浏览器而不同（大约6个）
- 管道机制，在同一个TCP连接中可以发送多个请求，但服务器依然会按照发送顺序处理请求，因此如果前面的请求处理时间特别久后面的请求就会被阻塞，这就是队头阻塞
- 1.1可以用Content-Length来标记数据块的长度，当为0时说明发送完成，但必须等服务处理完才知道大小。（1.0不需要，因为一个TCP只有一个请求，关闭即完成）
- 为了减缓多个请求的阻塞可以用流模式（stream）或缓存模式（buffer），产生一块数据就发送一块数据，因此1.1可以使用Transfer-Encoding字段表明回应将有数量未定的数据块组成。Transfer-Encoding: chunked。每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。
- 1.1还增加了PUT、PATCH、HEAD、OPTIONS、DELETE方法
- 客户端的请求头增加了Host字段声明来指定服务器的域名。有了Host字段，就可以将请求发送到同一台服务器上的不同网站，为虚拟主机打下基础。

缺点：

- 虽然1.1允许复用TCP连接，但仍然是按次序响应请求的，只有处理完一个回应，才会进行下一个回应，存在队头阻塞问题。
  - 解决方法1：减少请求数（如合并脚本和样式表、图片嵌入CSS代码）
  - 解决方法2：多开持久连接（如域名分片）

### HTTP/2

09年谷歌发布SPDY协议，主要解决1.1的效率问题，验证后作为HTTP2的基础。

- 无子版本、下一个版本将是3
- 彻底的二进制协议，头信息和数据都是二进制，统称为帧（frame），头信息帧和数据帧
  - 二进制协议的好处是可以定义额外的帧，为将来的高级应用打基础。文本的解析比较麻烦，二进制解析方便得多。
- 多路复用（多工：双向的、实时的通信），在一个TCP连接中，客户端和浏览器都可以发送多个请求或回应，而不用按照顺序一一对应，避免了队头阻塞
- 数据流
  - 2的数据包不按顺序发送，而是以数据流（每个请求或回应的所有数据包）的方式发送，每个数据流都有一个唯一的ID，且客户端为奇数，服务端为偶数。
  - 数据流发送到一半时，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。（1.1取消请求的唯一方式是关闭TCP连接）
  - 客户端可以指定数据流的优先级，优先级越高服务器越早响应
- 头信息压缩
  - HTTP协议是无状态的，每次请求都必须附带所有的信息，因此很多字段是重复的，如Cookie和User Agent的内容是相同的，每次请求都要附带，浪费带宽和速度
  - HTTP/2引入了头信息压缩机制，头信息可以使用gzip或compress压缩后发送，另一方面，客户端和服务器同时维护同一张表，所有字段都会存入这张表，生成一个索引号，以后就不发送同一字段，而是发送索引号即可。
- 服务器推送
  - HTTP/2允许服务器未经请求主动向客户端发送资源（server push）
  - 常见的场景如请求一个网页，网页中包含许多静态资源，而正常情况下需要等到解析HTML时再去发起静态资源的请求，而现在服务器可以预判到客户端请求网页后需要哪些静态资源，连同HTML一起发送到客户端。



<hr/>

## 参考资料来源

- [写给女朋友的中级前端面试秘籍（含详细答案，15k级别）](https://juejin.cn/post/6844904115428917255#heading-25)

- 
