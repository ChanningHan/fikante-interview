# 项目复盘



## ait-tutor-board



1. 重构内容

   首先指令是指服务端向讲题板终端通过WebSocket发送的消息，讲题板接收到指令后根据指令内容执行相应的事件，比如显示题目，解说等等，这中间需要一个指令的处理器来处理这些事情。在重构前的版本中，是使用RxJS来将指令消息处理为响应式流，本质上就是一个发布订阅的过程，但整个应用实际上只有这一处使用到了RxJS，有点大材小用了，并且由于RxJS本身的复杂度加上实现后整个指令处理流程的复杂度，至少我在刚接手这个项目的时候是比较痛苦的，当时大概花了一个星期的时间去学习RxJS后再重新去看这部分的代码才能够将这部分理清楚，这可能对于后续开发者而言也是一个痛点，并且在当时并不能很轻松地介入到这个流程中去做一些中间过程的处理。但在理清整个流程后其实对于指令的处理通过策略模式的一个处理器对象就可以完成，并且可以很轻松地在上面做扩展或钩子，比如可以根据环境执行同一个指令的不同执行器程序，将指令执行器以单文件的形式定义，甚至做一些自动化的手段。

   

2. 如何重构？如何保障重构？

   首先是分析现有模块的痛点，找到重构的切入点和解决方案，再设计这个模块重构的框架，我个人比较喜欢结合流程图去表达整个模块功能的运转，然后结合适当的补充说明的方式去做功能模块设计。

   其次是保证重构后的模块是能够正常运转的，重构中最好不要改变原有或新增删除功能。

   然后是一次重构的范围不能太大，时间不能太长，不然与旧版本的维护或迭代的差距太大在合并的时候难度很高。

   在重构的过程中在旧版本上进行的维护和小迭代，要考虑如何在重构后的模块中进行实现。

   与测试的同事合作，重构前准备好足够覆盖率的测例，在每个重构节点完成后进行端到端的测试验证保证重构的正确性。

   另外的话就是重构的时间点，最好是在迭代的低峰期进行，同时尽可能的越早越好。

   

3. 多端响应式样式框架

   由于讲题板覆盖了从移动端、Pad端、PC端到大屏的应用场景，那么之前是在不同的场景下需要开发人员对样式进行手动的细节处理，比如字体的大小，常常会根据设计和产品提出的要求在不同设备场景下进行一个适当的缩放，开发人员只能够根据需求东改一点西调一点，甚至有种按下葫芦浮起瓢的感觉。那么根据这一痛点，我开始想的是用PostCSS的插件px-to-vw来进行响应式的自动缩放处理，但是很快发现这东西其实并不能满足我们的场景，因为它只能配置一个页面宽度，并在实际的场景中根据这个宽度去进行缩放，这种无脑缩放的方式就会导致在屏幕宽度跨度较大的时候出现巨无霸一样的样式，比如早期的饿了么Web端就是如此，它定的宽度是移动端的宽度，然后到了PC端上等比例放大以后里面的样式就变得巨大无比。所以在这个问题上如果能让这个插件设置多个屏幕宽度，这个问题也就引刃而解了。

   但我当时查阅了很多资料，甚至到这个插件的issue里面去翻阅是否有解决方案，我看到里面也有不少用户因为这一个问题提出了issue，或者提出了一些配置的提案去解决这个问题，但可惜的是并没有给出解决方案，对提案也还没有实现。这个问题也是困扰得我一晚上睡不着觉。后来忽然灵光一闪，从另一个角度找到了切入点，就是结合rem和vw的特性，将插件配置中px转向的单位从vw变成rem，然后在html元素样式上用媒体查询为多个分辨率设置与配置中宽度成比例的字体大小，且单位为vw，当然这个值是经过一些推导过程得出的，这样经过多一层的转换就可以应用多个屏幕宽度的配置。让应用的样式既能够在每个分辨率区间之间进行响应式的伸缩，又不会因为跨度过大而导致被伸缩得太离谱。

   比如插件配置中写的宽度是375px，那么在html的媒体查询样式中定义375分辨率下字体大小为1vw，1080分辨率下则为(375 / 1080) vw。

   那么一个16px的文字在375屏幕下是16px，然后随着屏幕变大进行等比例放大，在1080屏幕下又收缩回了16px，之后继续放大，以此类推，既能够在每个分辨率区间之间进行响应式的伸缩，又不会因为跨度过大而导致被伸缩得太离谱。

4. 导航模块

   导航是在当讲解内容中出现讲解链接，该链接为一个完整讲解，相当于另一个讲题板应用，点击链接后打开该链接的讲解页面，返回时保持原讲解的进度。

   当时针对这个需求有想过三种方案，第一种是重构现有的项目，在同一个工程下维护多个讲解的状态和处理逻辑，但是这违背了目前项目的架构设计与实现，进行重构的话需要进行彻底的打碎整合，这种方式的成本太大，并不合适目前的迭代计划。

   第二种是引入微前端的解决方案，需要新的入口应用作为容器，通过手动挂载的方式将讲题板挂载到应用中，并通过入口应用对多个讲题板进行管理。这种方案对讲题板应用本身架构无侵入性，但由于引入了容器应用，需要改造现有部署方案。

   第三种是基于 Iframe 与 postMessage，将导航中的子页面以iframe挂载到原讲解上，并以Modal的形式呈现，页面间的通信由postMessage进行，实现起来较为轻量，于是就敲定以这种方式展开。其中的难点主要在于页面间的通信处理、状态的管理，且应用本身的交互形态较复杂，交互发生时的通信处理较繁杂。虽然是不同页面的通信，但这些页面对应的是同一工程，需要注意套娃引起的各种问题（如自己发消息给自己，接收到又发送给自己，掉入死循环），否则程序容易崩溃。最后基于这种方案设计并实现了贯穿导航流程的通信机制/协议以及模块化的状态管理。

   

5. 细粒度暂停

   通过分析各指令执行实现及动画执行机制，为每个可暂停任务实现并注册为暂停事件，通过发布订阅模式串联所有的细粒度暂停事件。

6. 题图答案渲染器

​		基于Canvas与面向对象的编程范式，划分为处理器、目标渲染器类。由处理器类根据指令内容进行调度对应的目标渲染器，并实现碰撞检测机制保证渲染内容的完整性。

​		难点1: 题图渲染，根据算法计算的结果，对图片中文本根据bounding Box进行文本元素生成并覆盖，以支持图片上文本的交互与渲染进一步处理。对文本的字号大小进行了三次计算和矫正，首先是根据BoudingBox的高度进行推算大概的字号，然后进行渲染，第二次是根据渲染的实际宽度和BoundingBox的宽度的比例计算字号需要缩放的比例，矫正后再进行一次渲染，然后根据渲染的实际高度和BoundingBox高度的比例计算字号的缩放比例，然后完成最后一次渲染。

​	  难点2: 在填空题的答案渲染中，对于超长答案需要以移动到横线下方无遮挡的区域，尤其是当有多个超长答案存在的情况下，需要处理这些答案的布局关系。这里我通过与其它文本的BoudingBox和超长答案块进行碰撞检测，当碰撞发生时根据先后顺序进行一定的位移，直到无碰撞发生。

​	难点3: 在连线题的答案渲染中，需要对两个目标区域的BoundingBox的中心点进行连线，并且连线不能出现在两个BoundingBox内部。如果直接连接两个BoudingBox的中心点是简单的，但是如果不能出现在两个BBox内的话就需要计算出这个连线与BBox边框上的交点再连接两个交点，这里还需要考虑各种边界情况的计算方式，是比较麻烦的。后来想到WebGL里面反面可以不渲染来提高性能的一些概念吧，然后再查了查Canvas的相关文档，其中有个概念叫非零环绕原则，于是我利用这个特点，将涵盖两个BBox的大矩形作为一个ClipPath，然后反方向画两个BoundingBox区域的ClipPath，再直接将两个BBox中心点一连就完事了，如此只有两个BBox区域外的线会被渲染。
